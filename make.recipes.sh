#!/usr/bin/env bash
#################################################################
# See recipes of Makefile
#################################################################

vm_ip(){
    # Print IPv4 address of an ssh-configured Host ($1). 
    [[ $1 ]] || return 99
    echo $(cat ~/.ssh/config |grep -A4 -B2 $1 |grep Hostname |head -n 1 |cut -d' ' -f2)
}
settings_inject(){
    [[ -r $1.tpl ]] || return 11
    [[ $(echo "$1" |grep 'join') ]] && {
        [[ $K8S_CERTIFICATE_KEY ]] || 
            export K8S_CERTIFICATE_KEY="$(
                cat "$( find logs -type f -iname '*init-now*.log' |sort |tail -n1)" \
                    |grep -- --control-plane |command grep -- --certificate-key |awk '{print $3}'
            )"
        [[ ${K8S_CERTIFICATE_KEY} ]] || return 22
    }
    #printf "%s\n%s\n%s\n%s\n" '---' "## This file is DYNAMICALLY GENERATED by make recipes" "## Template: ${1##*/}.tpl" '---' |tee $1
    cat $1.tpl \
        |sed "s,K8S_VERSION,${K8S_VERSION/v/},g" \
        |sed "s,K8S_VERBOSITY,${K8S_VERBOSITY},g" \
        |sed "s,K8S_CLUSTER_NAME,${K8S_CLUSTER_NAME},g" \
        |sed "s,K8S_NODE_INIT,${K8S_NODE_INIT},g" \
        |sed "s,K8S_REGISTRY,${K8S_REGISTRY},g" \
        |sed "s,K8S_NETWORK_DEVICE,${K8S_NETWORK_DEVICE},g" \
        |sed "s,K8S_CONTROL_IP,${K8S_CONTROL_IP},g" \
        |sed "s,K8S_CONTROL_PORT,${K8S_CONTROL_PORT},g" \
        |sed "s,K8S_CONTROL_ENTRYPOINT,${K8S_CONTROL_ENTRYPOINT},g" \
        |sed "s,K8S_SERVICE_CIDR,${K8S_SERVICE_CIDR},g" \
        |sed "s,K8S_NODE_CIDR6_MASK,${K8S_NODE_CIDR6_MASK},g" \
        |sed "s,K8S_NODE_CIDR_MASK,${K8S_NODE_CIDR_MASK},g" \
        |sed "s,K8S_POD_CIDR6,${K8S_POD_CIDR6},g" \
        |sed "s,K8S_POD_CIDR,${K8S_POD_CIDR},g" \
        |sed "s,K8S_CRI_SOCKET,${K8S_CRI_SOCKET},g" \
        |sed "s,K8S_CGROUP_DRIVER,${K8S_CGROUP_DRIVER},g" \
        |sed "s,K8S_BOOTSTRAP_TOKEN,${K8S_BOOTSTRAP_TOKEN},g" \
        |sed "s,K8S_CERTIFICATE_KEY,${K8S_CERTIFICATE_KEY},g" \
        |sed "s,K8S_CA_CERT_HASH,${K8S_CA_CERT_HASH},g" \
        |sed "s,K8S_JOIN_KUBECONFIG,${K8S_JOIN_KUBECONFIG},g" \
        |sed "/^ *,/d" |sed "/^\s*$/d" |sed '/^[[:space:]]*#/d' \
        |tee $1
}
settings_purge(){
    
	cat <<-EOH |tee Makefile.settings
	## This file is DYNAMICALLY GENERATED at make recipes
	export K8S_CERTIFICATE_KEY ?= $(kubeadm certs certificate-key)
	export K8S_CA_CERT_HASH    ?=
	export K8S_BOOTSTRAP_TOKEN ?=
	EOH
}
halb(){
    echo "‚ÑπÔ∏è This method is DEPRICATED : Use project github.com/sempernow/halb"
    # Function halb generates the configuration for a 2-node 
    # Highly Available Load Balancer (HALB) built of HAProxy and Keepalived.
    # Configuration files, haproxy.cfg (LB) and keepalived-*.conf (HA; node failover),
    # are generated from their respective template file (*.tpl).
    pushd halb || return 111
    # VIP must be static and not assignable by the subnet's DHCP server.
    vip='192.168.0.100' 
    vip6='::ffff:c0a8:64'
    device='eth0' # Network device common to all LB nodes
    # Set FQDN
    lb_1_fqdn='a0.local'
    lb_2_fqdn='a1.local'
    # Get/Set IP address of each LB node from ~/.ssh/config
    lb_1_ipv4=$(vm_ip ${lb_1_fqdn%%.*})
    lb_2_ipv4=$(vm_ip ${lb_2_fqdn%%.*})
    # Smoke test these gotten node-IP values : Abort on fail
    [[ $lb_1_ipv4 ]] || { echo 'ERR : @ lb_1_ipv4';return 22; }
    [[ $lb_2_ipv4 ]] || { echo 'ERR : @ lb_2_ipv4';return 23; }

    target=keepalived-check_apiserver.sh
    cp ${target}.tpl $target
    sed -i "s/SET_VIP/$vip/" $target

    # Generate a password common to all LB nodes
    pass="$(cat /proc/sys/kernel/random/uuid)" 
    
    target=keepalived.conf
    cp ${target}.tpl $target
    sed -i "s/SET_DEVICE/$device/" $target
    sed -i "s/SET_PASS/$pass/" $target
    sed -i "s/SET_VIP/$vip/" $target
    # Keepalived requires a unique configuration file 
    # (keepalived-*.conf) at each HAProxy-LB node on which it runs.
    # These *.conf files are identical except that "priority VAL" 
    # of each SLAVE must be unique and lower than that of MASTER.
    cp $target keepalived-$lb_1_fqdn.conf
    cp $target keepalived-$lb_2_fqdn.conf
    rm $target
    target=keepalived-$lb_2_fqdn.conf
    sed -i "s/state MASTER/state SLAVE/"  $target
    sed -i "s/priority 255/priority 254/" $target

    # Replace pattern "LB_?_FQDN LB_?_IPV4" with declared values.
    target=haproxy.cfg
    cp ${target}.tpl $target
    sed -i "s/LB_1_FQDN[[:space:]]LB_1_IPV4/$lb_1_fqdn $lb_1_ipv4/" $target
    sed -i "s/LB_2_FQDN[[:space:]]LB_2_IPV4/$lb_2_fqdn $lb_2_ipv4/" $target

    chmod +x *.sh

    ls -hlrtgG --time-style=long-iso

    popd
}
kubeconfig(){
    [[ $K8S_NODE_INIT ]] || { echo 'ERR : K8S_NODE_INIT is UNSET'; return; }
    ssh ${ADMIN_USER}@${K8S_NODE_INIT} '
      sudo cp -p /etc/kubernetes/*admin.conf .
      sudo chown $(id -u):$(id -g) *admin.conf
    '
    mkdir -p ~/.kube

    scp -p $K8S_NODE_INIT:*admin.conf ~/.kube/ && {

        target=~/.kube/config
        [[ -f $target ]] &&
            mv $target $target.$(date '+%F.%T' |sed s,:,.,g)

        mv ~/.kube/admin.conf $target
        [[ -d ~/.kube/cache ]] && sudo rm -rf ~/.kube/cache
        chmod 600 ~/.kube/conf*

        kubectl config set-context --current --namespace kube-system
        kubectl get no -o wide &&
            kubectl get po -o wide -A

    } || echo "‚ö†Ô∏è  ERR : Failed to pull kubeconfig" >&2

}
iperftest(){
    echo '‚ÑπÔ∏è This method is DEPRICATED : Run `make iperf`'
    return 0

    ns=default
    pod=nbox
    img=nicolaka/netshoot

    # Server
    kubectl -n $ns run $pod --image=$img --wait -- iperf3 -s
    sleep 3
    node=$(kubectl -n $ns get pod $pod -o jsonpath='{.spec.nodeName}')
    ip=$(kubectl -n $ns get pod $pod -o jsonpath='{.status.podIP}')

    # Clients

    echo === Pod traffic : Same node
    kubectl -n $ns run ${pod}-client -it --rm \
        --image=$img \
        --overrides='{"spec": {"nodeName": "'$node'"}}' \
        --restart=Never -- \
        iperf3 -c $ip

    sleep 3

    echo === Pod traffic : Cross nodes
    node=$(kubectl get node --no-headers |cut -d' ' -f1 |grep -v $node |head -n1)
    kubectl -n $ns run ${pod}-client -it --rm \
        --image=$img \
        --overrides='{"spec": {"nodeName": "'$node'"}}' \
        --restart=Never -- \
        iperf3 -c $ip

    kubectl -n $ns delete pod $pod
}
prune(){
    echo -e "üöß === Deleting problemed Pods across all Namespaces ‚Ä¶"
    for stat in ${ADMIN_PODS_PRUNE}; do 
        echo -e "\nüîß Delete all Pods having STATUS: $stat"
        kubectl get pod -A -o wide |grep '\b'$stat'\b' |awk '{print $1,$2}' |xargs -n2 /bin/bash -c '
            [[ $2 ]] || {
                echo "   There were none."
                exit 0
            }
            kubectl -n $1 delete pod $2 ||
                echo "‚ö†Ô∏è Something went wrong deleting Pod: $2 in Namespace: $1"
        ' _
    done
    return 0
}
etcdLogs(){
	podLog(){
        local since=''
        [[ $2 ]] && since="--since=${2}"
        echo "‚ÑπÔ∏è etcd-$1 : Logs $since @ $(date -uIm)"
        #kubectl logs -n kube-system etcd-$1 |jq -Mr . |jq -Mr . --slurp |jq -Mr '.[] | select(.level != "info")'; return
        kubectl logs -n kube-system etcd-$1 $since \
            |jq -Mr . |jq -Mr . --slurp \
            |jq -Mr '.[] | select(.level != "info") 
                | [.ts, .msg, .took, .duration, .error, .["time spent"] ]
                | join("\t")
            '
            echo
    }
    export -f podLog
    local since=$1
    printf "%s\n" ${K8S_NODES_CONTROL} |xargs -n1 /bin/bash -c 'podLog $1 $0' $since 2>/dev/null
    
}
sudoer(){
    group=ad-linux-sudoers
    ANSIBASH_TARGET_LIST=${ADMIN_TARGET_LIST} &&
        ansibash -c '
            sudo mkdir -p /etc/sudoers.d
			sudo tee /etc/sudoers.d/'$group' <<-EOH
			%'$group'  ALL=(ALL) NOPASSWD: ALL
			Defaults:%'$group'  secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin
			EOH
            sudo chmod 640 /etc/sudoers.d/'$group'
            sudo systemctl daemon-reload
        '
}
rebootSoft(){
    awaitNodeReady(){
        node=$1
        timeout=300
        elapsed=0
        interval=5

        echo -e "\n‚åõ K8s : Await 'Ready' status of node $node"
        while true; do
            status=$(kubectl get node "$node" -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "NotFound")
            [[ "$status" == "True" ]] && {
                echo -e "‚úÖ K8s : Node $node is Ready.\n"
                break
            }
            (( elapsed >= timeout )) && {
                echo -e "‚ùå K8s : Node $node status remains NOT Ready after $timeout seconds.\n"
                
                return 11
            }
            sleep $interval
            ((elapsed += interval))
        done
    }
    export -f awaitNodeReady
    nodes="$@"
    domain=${HALB_DOMAIN:-HALB_DOMAIN}
    flag_node_timeout=''

    [[ $(kubectl config get-contexts --no-headers) ]] || {
        printf "%s\n   %s\n" \
            "‚ùå This method requires client (kubectl) communication with K8s API;" \
            "however, kubectl is entirely unconfigured; has no kubeconfig."
            return 1
    }

    echo -e "üõ†Ô∏è === $FUNCNAME : Soft reboot of K8s nodes: $nodes : drain ‚ûî  reboot ‚ûî  uncordon"

    for node in $nodes; do

        [[ $flag_node_timeout ]] && {
            echo "‚ö†Ô∏è Skip this node ($node) because prior node ($flag_node_timeout) FAILED TO RECOVER from its reboot within timeout."
            break
        }
        nslookup $node.$domain >/dev/null 2>&1 || { 
            echo "‚ö†Ô∏è Skip this node ($node) because DNS does NOT RESOLVE '$node.$domain'"
            break
        }
        echo -e "\nüîß === Node: $node"

        echo -e "\n‚ÑπÔ∏è K8s : Cordon and drain node $node ..."
        ## Failure of cordon/drain may occur due to various causes local to that node. 
        ## Continue to process other nodes regardless of cordon/drain failure,
        ## and handle such problemed node(s) issues manually afterward.
        kubectl drain $node --ignore-daemonsets --delete-emptydir-data --force || {
            echo "‚ùå K8s : ERR at kubectl drain $node ..." 
            # Undo the effect of (failed) drain; allow K8s to schedule new Pods here as we process (drain) other nodes.
            kubectl uncordon $node 
            break
        }

        echo -e "\n‚ÑπÔ∏è Host : Command reboot of node $node ..."
        ssh -t $node 'sudo reboot;sleep 300'
        echo -e "‚ÑπÔ∏è Host : ...node $node is rebooting." 

        ## If this K8s Node fails to recover (STATUS: Ready) after reboot (within declared timeout), 
        ## then we don't do anything to any other nodes remaining of this loop.
        awaitNodeReady $node || export flag_node_timeout=$node
        
        ## Bypass the External Load Balancer to hit an endpoint at *this* node's instance of K8s API server.
        request="https://$node.$domain:6443/healthz"
        echo -e "‚åõ K8s : Await expected response from API server on subject node : $request"
        while true; do
            curl -fksIX GET --connect-timeout 3 $request |grep 200 |grep HTTP &&
                break
            sleep 5
        done

        echo -e "\n‚ÑπÔ∏è K8s : Uncordon node $node ..."
        kubectl uncordon $node

    done

    echo -e "\n‚úÖ $FUNCNAME : Completed."
}
rootCA(){
    echo "‚ÑπÔ∏è This method is DEPRICATED : Use project github.com/sempernow/window-server"
   
    return 0
    
    ## Below is 2025-08-09 copy/mod of same func at windows-server project 
    len=4096
    days=3650
    ca_ext=v3_ca
    cn=${DC_TLS_CN:-Penguin Root CA}
    o=${DC_TLS_O:-Penguin Inc}
    ou=${DC_TLS_OU:-gotham.gov}
    c=${DC_TLS_C:-US}

    dir=${PRJ_ROOT:-__PRJ_ROOT_is_unset__}/ingress/tls/root-ca
    [[ -d $dir ]] || {
        echo "‚ùåÔ∏è  ERR : Path does NOT EXIST : '$dir'" >&2
        return 11
    }
    rm -rf $dir/*.*
    path="$dir/${cn// /-}"
    
    echo "üõ†Ô∏è  Create all PKI of the Root CA" >&2

	tee $path.cnf <<-EOH
	# Generated @ ${BASH_SOURCE##*/}
	[ req ]
	prompt              = no
	default_bits        = $len
	default_md          = sha256
	distinguished_name  = req_distinguished_name
	x509_extensions = $ca_ext
	[ req_distinguished_name ]
	CN  = $cn
	O   = $o
	OU  = $ou
	C   = $c
	[ $ca_ext ]
	basicConstraints        = critical, CA:TRUE # Append pathlen:1 to limit chain to one subordinate CA
	keyUsage                = critical, digitalSignature, keyCertSign, cRLSign
	subjectKeyIdentifier    = hash
	EOH

    ## Generate key and CSR  : -noenc else -aes256 to encrypt w/ AES-256 (password)
    openssl req -new -config $path.cnf -noenc -newkey rsa:$len -keyout $path.key -out $path.csr
    ## Sign the root cert with root key, applying the extensions of CSR
    openssl x509 -req -in $path.csr -extensions $ca_ext -extfile $path.cnf -signkey $path.key \
        -days $days -sha384 -out $path.crt
    
    # ## Generate both key and cert from CNF in one statement; skip the CSR
    # openssl req -x509 -new -nodes -keyout $path.key -days $days -config $path.cnf -extensions v3_ca 
    #     -out $path.crt

    echo "üîç  Parse the certificate located at '$path.crt'" >&2 # man x509v3_config
    # The extension (x509v3) of most interest in leaf certs is subjectAltName (SAN); other ext's are mostly inspected of CA certs.
    x509v3='subjectAltName,issuerAltName,basicConstraints,keyUsage,extendedKeyUsage,authorityInfoAccess,subjectKeyIdentifier,authorityKeyIdentifier,crlDistributionPoints,issuingDistributionPoints,policyConstraints,nameConstraints'
    openssl x509 -noout -subject -issuer -startdate -enddate -ext "$x509v3" -in $path.crt \
        |tee $path.crt.parse

}

"$@" || echo "‚ùå  ERR : $?" >&2